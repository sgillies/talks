<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Fiona and Rasterio</title>

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="../css/reveal.css">
        <link rel="stylesheet" href="../css/theme/black.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="../lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = 'css/print/pdf.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

    <div class="reveal">
    <div class="slides">

    <!-- Title -->
    <section
            data-background="img/rgba30.png" 
            data-background-size="1000px">

        <h1>Writing, Running, and Distributing</h1>
        <h2>Modern Python GIS Software</h2>
        <p>Sean Gillies &#8729; Mapbox</p>
        <p><small>GeoRodeo 2015 &#8729; Austin &#8729; May 22</small></p>

        <aside class="notes">
        Hi! Good morning! Thank you very much for coming to this sessiom. My name
        is Sean Gillies, I work at Mapbox.  I've been a Python programmer since
        2001 and a GIS analyst and programmer since 1999, with a s√©jour in the
        digital classics from 2006 to 2013.  This is my first GeoRodeo.
        </aside>

    <!-- End Title -->
    </section>

    <!-- Intro -->
    <section>

        <section>
            <h2>Mapbox Front Office</h2>
            <img src="img/mbmobile.png">

            <aside class="notes">
                We launched an SDK for iOS this week. Great design is 
                a big part of this. So is system architecture. Do you know
                what else is a big part of our platform?
            </aside>

        </section>

        <section data-background="img/1024px-Archaeology_dirt_screening.jpg">
            <h1 style="color:white">The Back Office</h1>
            <aside class="notes">
                
                Geospatial data processing. Good data is essential. Good data
                requires a lot of hard work.

                At Mapbox, I get to write software to make data processing
                easier, more fault tolerant, more predictable, more scalable.
                Fun, even. That's what I aspire to.

                The Python programming language is a big part of data 
                processing at Mapbox. I'm going to talk this morning about
                Python's role in GIS, lessons I'm learning about using it,
                and try to share a few lessons. 

            </aside>
            
        </section>

        <section>
            <h2>A Brief History of Python and GIS</h2>
            <img src="img/python.png">
        </section>

        <section>
            <h2>In the Beginning there was AVPython</h2>
            <img src="img/avpython.png" width="800">

            <aside class="notes">

            Bruce Dodson was an employee of Esri Canada.

            In a reply, Norman Vine pointed out that the UMN MapServer
            project had Perl bindings.

            In 2000, this would have been Python version 1.5.2.

            I was an ArcView user in 2000, but didn't find out about 
            AVPython until 2002, after I'd moved on from my job at the
            GIS shop.

            </aside>
        </section>

        <section>
            <h2>Then GDAL</h2>
            <img src="img/gdal-py.png" width="800">

            <aside class="notes">

            The GDAL project went with SWIG for scripting language
            bindings, but with Python (like AVPython) instead of Perl.
            Norman Vine had some influence here.

            </aside>
        </section>

        <section>
            <h2>After GDAL</h2>
            <ul>
                <li>PyTerra, MapServer (2002)</li>
                <li>ArcGIS (2004), QGIS (2006?)</li>
                <li class="fragment">15 years of Python and GIS</li>
            </ul>
        </section>

        <!-- Why Python Today? -->
        <section
                data-background="img/1200px-LTD_Crown_Victroia_S.jpg">
            <aside class="notes">

            Why Python? Isn't it yesterday's language? Isn't Python slow and
            a waste of energy? A gas guzzler? Shouldn't I be thinking more of
            the polar bears?  It doesn't even run in my browser. Why Python?

            </aside>

        </section>

        <section>
            <h2>Why Python Today?</h2>
            <ul>
                <li class="fragment">Scientific computing: Numpy, SciPy, scikit-learn &c</li>
                <li class="fragment">A Very Big GIS Product</li>
                <li class="fragment">It's still fun to use</li>
            </ul>

            <aside class="notes">
            Python isn't the cool or cutting edge language where I work. Not by a long
            shot. We use it at Mapbox because it has more features or more maturity
            in some important domains. You might be in the same boat as me.

            Python's scientific, engineering, and mathematics software ecosystem is
            exceptional. The Numpy, Scipy, and Scikit projects are heavy lifters with
            no mature equivalents in Node.js.

            For us in this room, it's also significant that Python is the primary
            scripting language for Esri's ArcGIS and also QGIS.

            Python still matters. It's a great general purpose language and is
            very strong in the rapidly growing data science field. It remains
            a very useful language for GIS.

            </aside>
        </section>

        <section>
            <h2>In this Talk</h2>
            <ul>
                <li>How to w<b style="color:yellow">rite</b> good Python programs</li>
                <li>How to w<b style="color:yellow">rangle</b> and distribute them</li>
                <li>How to deploy and <b style="color:yellow">run</b> them</li>
            </ul>

            <aside class="notes">
            I'm going to talk about "The Three R's" and how to profit from them.
            How to process more data, faster.

            You'll see the unix bash shell in my examples, but everything I'm going
            to talk about translates fairly well to Windows and PowerShell.
            </aside>
        </section>

        <section>
            <h2>Not in this Talk</h2>
            <ul>
                <li>Web frameworks</li>
                <li>Graphical user interfaces</li>
            </ul>

            <aside class="notes">
            Python has many mature web frameworks and we don't have time to
            cover them.

            GUI development has never been Python's strong suite and between
            other Native SDKs (iOS, whatever) and modern browser-based apps,
            I don't see room for Python to improve here.

            </aside>
        </section>

    <!-- End Introduction -->
    </section>

    <!-- Begin Writing Python -->

    <section>

        <section>
            <h2>Writing Python</h2>
            <ul class="fragment">
                <li>Making it good</li>
                <li>Making it fast</li>
            </ul>

        </section>

        <section>
            <h2>Test Early, Test Often</h2>
            <img src="img/passing.svg" height="100" border="0">
            <img src="img/coveralls_100.svg" height="100" border="0">

            <aside class="notes">

            It's never to early to start testing your code. The longer you
            wait to start testing, the harder it is to write the tests. Start
            while it's easy.

            There are a number of ways to test Python code. The good ones 
            make it easy to get started. I like "pytest".

            </aside>
        </section>

        <section>
            <h2>Pytest</h2>
            <pre><code data-trim>
"""script.py: print 'Spam and Eggs'."""


def get_msg():
    return "Spam and Egs"


# This is a test.
def test_get_msg():
    assert get_msg() == "Spam and Eggs"


if __name__ == '__main__':
    print(get_msg())
</code></pre>
            <aside class="notes">

            For pytest, you write functions that start with "test" and make
            assertions. No xUnit boilerplate. Your first tests are as simple
            as that. As I'm showing here, you can even put the tests inside
            your script, although we usually keep the tests outside in 
            another module as they grow.

            </aside>
        </section>

        <section>
            <h2>Assertion Introspection</h2>
            <pre><code data-trim>
$ py.test script.py
=================================== FAILURES ===================================
_________________________________ test_get_msg _________________________________

    def test_get_msg():
>       assert get_msg() == "Spam and Eggs"
E       assert 'Spam and Egs' == 'Spam and Eggs'
E         - Spam and Egs
E         + Spam and Eggs
E         ?            +

script.py:10: AssertionError
=========================== 1 failed in 0.01 seconds ===========================
</code></pre>
            <aside class="notes">

            Pytest works by modifying the abstract syntax tree of your
            module in a process its author calls "assertion introspection."
            
            Instead of an AssertionError, you get a comparison of the 
            values on either side of the assertion and helpful clues.
            </aside>
        </section>

        <section>
            <h2>Coverage</h2>
            <pre><code data-trim>
$ py.test script.py --cov script --cov-report=term-missing
============================= test session starts ==============================
platform darwin -- Python 2.7.9 -- py-1.4.26 -- pytest-2.6.4
plugins: cov
collected 1 items

script.py .
--------------- coverage: platform darwin, python 2.7.9-final-0 ----------------
Name     Stmts   Miss  Cover   Missing
--------------------------------------
script       6      1    83%   14

=========================== 1 passed in 0.01 seconds ===========================
</code></pre>
            <aside class="notes">

            Pytest has a handy code coverage plugin, too.
            </aside>
        </section>


    <section>
    <h2>Slow code, fast code</h2>
    <pre><code class="python" data-trim>
# C style.
nums = []
for i in range(100):
    nums.append(i)
    </code></pre>

    vs

    <pre><code class="python" data-trim>
# Python style.
nums = [i for in range(100)]
    </code></pre>

<aside class="notes">

Don't write slow code. Write fast code.

First, I'm showing the most imperative, C-like way of making a Python list of the first 100 numbers.
Next, the most idiomaticly Python way of doing it.
</aside>

    </section>

    <section>
    <h2>Not just less code ‚Äì faster</h2>
    <pre><code class="bash" data-trim>
$ python -m timeit -s "ns=[]" "for i in xrange(1000): ns.append(i)"
10000 loops, best of 3: 76.4 usec per loop
</code></pre>

vs

<pre><code class="bash" data-trim>
$ python -m timeit -s "ns=[i for i in xrange(1000)]"
100000000 loops, best of 3: 0.0108 usec per loop
</code></pre>

<aside class="notes">
The idomaticly Python way is faster. ridiculously faster!

Do this in your code.

Provide APIs like this in your Python packages.
</aside>
    </section>


        <section>
            <h2>Even faster: Numpy ufuncs</h2>

            <pre><code class="bash" data-trim>
# Initialized with -s "a = list(range(100000))"
$ python -m timeit "[val + 5 for val in a]"
100 loops, best of 3: 4.99 msec per loop

# Initialiazed with 
# -s "import numpy; a = list(range(100000)); a = numpy.array(a)" 
$ python -m timeit "a+5"
10000 loops, best of 3: 69.9 usec per loop
            </code></pre>

            <aside class="notes">
                I got this benchmark comparison from Jake VanderPlas.

                That's 70x faster!
            </aside>

        </section>

    <!-- End writing Python -->
    </section>

    <!-- Running Python -->
    <section>

        <section>
            <h2>Running Python</h2>
            <ul class="fragment">
                <li>Parallelism</li>
                <li>Dependency Management</li>
            </ul>

        </section>

        <section>
            <h2>Multiprocessing</h2>
            <pre><code class="python" data-trim>
from multiprocessing import Pool

def f(x):
    return x*x

if __name__ == '__main__':
    with Pool(5) as p:
        print(p.map(f, [1, 2, 3]))
            </code></pre>

            <p>See <a href="https://github.com/mapbox/rio-mbtiles">https://github.com/mapbox/rio-mbtiles</a> for a raster tiling example.</p>

            <aside class="notes">

            I rely on Python's multiprocessing module to parallelize data
            processing work and use all my computer's CPUs.

            Why not threading? Because Python's global interpreter lock
            ensures that only one thread in a process is running at a time.
            This means that threading is only useful for asynchronous I/O
            in Python.

            Multiprocessing can be very effective in processing raster data.
            I'm going to use as an example, the problem of turning a raster
            dataset in some projection into a set of web mercator (a different
            projection) tiles of many zoom levels.

            The example above comes from the Python docs. For my problem,
            what I pass to the pool's map() is descriptors of all my 
            mercator tiles and a function that, given, a tile descriptor,
            makes an destination raster - warps the source dataset into it -
            and returns that raster tile as a sequence of bytes.
        </section>

        <section>
            <h2>Requirement Hell</h2>
            <ul>
                <li class="fragment">Program A.py requires version 1.2.3 (exactly) of module X</li>
                <li class="fragment">Program B.py requires version 2.0.0 (or newer) of module X</li>                <li class="fragment">How can you get both scripts working at the same time?</li>
            </ul>

            <aside class="notes">
                Things are fairly simple if you're only using modules from 
                Python's standard library in your programs. But when you begin
                to use non-standard GIS modules, Numpy, SciPy, as we do, 
                managing dependencies becomes a little more difficult.

                How do we stay out of requirement hell as we deploy and run
                our programs?

                One solution is virtual environments.
            </aside>

        </section>

        <section>
            <h2>Virtualenv</h2>

            <ul>
                <li class="fragment">Every site/service/app has its own "venv" directory.</li>
                <li class="fragment">And its own "requirements.txt" file.</li>
            </ul>

            <aside class="notes">

            Virtualenv is a Python command. It creates "virtual environments":
            a Python executable and its own private non-standard modules,
            or what we call "site packages". I like to use virtualenv in a 
            way that reminds my colleagues of Node.js's node_modules directory.
            Because they are largely Node users.

            </aside>

        </section>

        <section>
            <h2>Virtualenv...</h2>
            
            <pre><code>
$ virtualenv venv
$ source venv/bin/activate
(venv)$ pip install -r requirements.txt
            </code></pre>

            <aside class="notes">

            This is more or less the equivalent of what "npm install" does
            for a Node.js project. Python doesn't have conventions like
            Node does (package.json and node_modules) and so you need to be
            more explicit.

            </aside>

        </section>

        <section>
            <img src="img/large_v-dark.png" width="600">

            <aside class="notes">

            Docker is a different approach to managing requirements. I'm 
            using it in several Python projects right now.

            You might use a Docker container instead of a virtualenv.

            </aside>

        </section>

        <section>
            <h2>Docker Example</h2>
            <pre><code class="bash">
$ docker run -itd --name tfrs \
> -v "/Users/sean/code/rasterio/tests/data:/mnt/data:ro" \
> mapbox/travis-frs:pre0 /bin/bash
87d7321ad492574f82c7957670c15e0067d4fcd5b3dd803bc3cef6fadd2e0aeb

$ docker exec tfrs rio shapes --mask /mnt/data/RGB.byte.tif \
> | geojsonio
            </code></pre>

            <aside class="notes">

            Docker is a different approach to managing requirements. I'm 
            using it in several Python projects right now.

            You might use a Docker container instead of a virtualenv.

            It's only a 15% slower than the native code on my MacBook. 
            Running on a better (Linux) host, the performance should be 
            excellent.
            </aside>

        </section>

        <section>
            <img src="img/Untitled.png" height="600">
        </section>

    <!-- End running Python -->
    </section>


    <section>
    
        <section>
        <h2>Distributing Python</h2>
        <ul class="fragment">
            <li>Publishing wheels</li>
            <li>Pluggability</li>
        </ul>
        </section>

        <section>
            <img src="img/Mars_rovers_wheels_isometric.jpg">
            <a href="http://pythonwheels.com/">http://pythonwheels.com/</a>
        </section>

        <section>
            <h2>Advantages of wheels</h2>
            <ul>
                <li>Faster installation for pure python and native C extension packages.</li>
                <li>Avoids arbitrary code execution for installation.</li>
                <li>Installation of a C extension does not require a compiler on Windows or OS X.</li>
            </ul>

            <aside class="notes">

            </aside>

        </section>

        <section>
            <h2>Plugins</h2>

            <pre><code class="python">
entry_points={'pytest11': ['pytest_cov = pytest_cov']},
            </code></pre>

            <aside class="notes">
            
            If you're building a pluggable Python program, such as pytest, 
            which I mentioned earlier, consider using Python's own plugin
            system instead of rolling your own.

            The code above is from the setup script of pytest's own coverage
            plugin.

            Pytest queries its Python for registered entry points to discover
            such plugins at run time.

            </aside>

        </section>

        <section>
            <h2>Rasterio Plugins</h2>
            <img src="img/poopy_plugin.png">

            <aside class="notes">
            
            We're using this same plugin system to make Rasterio's command
            line interface better organized and pluggable in a way that
            GDAL's utility suite (gdal_translate and friends) is not.

            If you look closely, you can see that we've added a little bit
            of emoji assistance to let you know if a third party plugin is
            broken.

            </aside>

        </section>
    <!-- End distributing Python -->
    </section>


    <section>
    <!-- Conclusion -->

    <section>
    <h2>Conclusion</h2>
    </section>

    <section>
    <h2>Writing Python</h2>
    <ul>
        <li>Test early and often</li>
        <li>Try pytest</li>
        <li>Use fast Python expressions</li>
        <li>Use Numpy for more speed</li>
    </ul>

    <aside class="notes">
    </aside>
    </section>

    <section>
    <!-- What I've told you -->
    <h2>Running Python</h2>
    <ul>
        <li>Try multiprocessing.Pool</li>
        <li>A virtualenv for every project</li>
        <li>Consider Docker</li>
    </ul>

    <aside class="notes">
    </aside>
    </section>


    <section>
    <!-- What I've told you -->
    <h2>Distributing Python</h2>
    <ul>
        <li>Build wheels to share modules</li>
        <li>Use pip to install modules</li>
        <li>For plugins: setuptools entry points</li>
    </ul>

    <aside class="notes">

    And once you've incorporated these tips, you're on your way to discovering
    that old gas guzzler is actually this...
    </aside>
    </section>

    <section data-background="img/1200px-Tesla_Model_S_Indoors.jpg">
    </section>

    </section>
    <!-- End conclusion -->

    <section>

    <h2>Project Links</h2>
    <ul>
      <li><a href="https://github.com/Toblerity/Fiona">https://github.com/Toblerity/Fiona</a></li>
      <li><a href="https://github.com/mapbox/rasterio">https://github.com/mapbox/rasterio</a></li>
      <li><a href="https://github.com/Toblerity/Shapely">https://github.com/Toblerity/Shapely</a></li>
      <li><a href="https://github.com/mapbox/rio-mbtiles">https://github.com/mapbox/rio-mbtiles</a></li>
    </ul>
    </section>

    <section>
        <h2>Thanks!</h2>
    </section>

    <!-- The end -->
    </section>

    <!-- end slides -->
    </div>

    <!-- end reveal container -->
    </div>

    <!-- Scripts below -->

        <script src="../lib/js/head.min.js"></script>
        <script src="../js/reveal.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme || 'night', // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Parallax scrolling
                // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
                // parallaxBackgroundSize: '2100px 900px',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '../plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
